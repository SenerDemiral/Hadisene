@using System.Text.Json
@page "/liste/{XXId:int}"
@rendermode @(new InteractiveServerRenderMode(prerender: false))
@inject AppState my
@inject IDbCon db
@inject IModalService Modal

<div style="display:inline-flex;justify-content:space-between;width:100%">
	<button @onclick="AddMaster">➕➕ Ekle</button>
	<button @onclick="Kaydet" data-changed="@hasChange">🆗 Kaydet @NOC</button>
</div>

<hr />

@if (sl?.Count > 0 && ttd != null && ssd != null)
{
	<table style="table-layout:auto;width:auto">
		<thead>
			<tr>
				<th>➕</th>
				<th>edit</th>
				<th>konu</th>
				<th>grup</th>
				<th>üye</th>
				<th>±gün</th>
				<th>zaman</th>
				<th>süre(s)</th>
				<th>➖</th>
			</tr>
		</thead>
		@{
			int i = 0;
			int oldId = sl[0].mXOId;
		}
		@foreach (var s in sl)
		{
			int idx = i;

			@if (oldId != s.mXOId) //oldId != sl[i].mXOId
			{
				oldId = s.mXOId; //oldId = sl[i].mXOId

				<tr>
					<td colspan="20" class="td-blnk"></td>
				</tr>
			}

			<tr data-deleted="@s.isDeleted" data-root="@s.pXOId">
				<td>@s.XOId</td>
				@if (s.pXOId == 0)    //sl[i].pXOId == 0
				{
					<td><button @onclick="@(() => AddSlave(idx))">➕@idx</button></td>
				}
				else
				{
					<td style="border-top-style: hidden;"></td>
				}
				<td>
					<button @onclick="@(() => ShowUpd(s))" data-edit="@s.isEdited">✒️</button>

				</td>
				<td class="inp-txt">@s.TskAd</td>
				<td class="inp-txt">@s.SrvAd</td>
				<td class="inp-txt">@s.ActAd</td>
				<td class="ta-c">@s.dGun</td>
				<td class="ta-c">@s.RSD.ToString("HH:mm")</td>
				<td class="ta-c">@s.RPH</td>
				<td><button @onclick="@(() => SilToggle(idx))">➖</button></td>
			</tr>

			i++;
		}
	</table>

	<datalist id="SSL">
		@foreach (var r in ssd!)
		{
			<option value="@r.Key" />
		}
	</datalist>
	<datalist id="TTL">
		@foreach (var r in ttd!)
		{
			<option value="@r.Key" />
		}
	</datalist>

}

<style>
	button[data-changed] {
		color: red;
	}

	button[data-edit] {
		background-color: aqua;
	}

	tr[data-deleted] {
		color: red;
	}

	tr[data-typ="D"] {
		color: red;
	}

	tr[data-root="0"] {
		/* font-weight: bold; */
		background-color: azure;
	}

	.td-blnk {
		height: 8px;
		/* background-color: aquamarine; */
	}

	th, td {
		/* border: none; */
	}

	.inp-txt {
		max-width: 20ch;
	}
</style>

@code {
	[Parameter] public int XXId { get; set; }
	List<XO> sl = new();
	private Dictionary<string, int>? ssd, ttd, sad;
	private bool hasChange;
	private int NOC;

	int c = -1;

	private void ChangeCount()
	{
		//NOC = sl.Count((z) => z.isEdited || (z.XOId > 0 && z.isDeleted));

		NOC = sl.Count((z) => 
			(z.XOId > 0  && (z.isEdited || z.isDeleted)) ||
			(z.XOId <= 0 && z.isEdited && !z.isDeleted));

		hasChange = NOC > 0 ? true : false;
	}

	public async Task ShowUpd(XO s)
	{
		ModalParameters mp = new();
		var cs = s.ShallowCopy();

		mp.Add("xo", cs);
		mp.Add("ssd", ssd);
		mp.Add("ttd", ttd);
		// mp.Add("XOId", s.XOId);

		var x = Modal.Show<XOupd>("", mp);

		var r = await x.Result;
		if (r.Confirmed)
		{
			s.isEdited = true;
			ChangeCount();

			s.dGun = cs.dGun;
			s.RPH = cs.RPH;
			s.RSD = cs.RSD;
			s.TskId = cs.TskId;
			s.TskAd = cs.TskAd;
			s.SrvId = cs.SrvId;
			s.SrvAd = cs.SrvAd;
			s.ActId = cs.ActId;
			s.ActAd = cs.ActAd;
			s.Inf = cs.Inf;
			s.Rf1 = cs.Rf1;
			s.Rf2 = cs.Rf2;
		}
	}


	private void Kaydet()
	{
		// Varsa Sil
		KaydetBeforeAfter(before: true);

		int oldPrnt = 0, newPrnt = 0, newId = 0;
		foreach (var s in sl)
		{
			// newId = WriteRec(s);
			// if (s.XOId < 0)
			// 	newId = d++;        // newId = XO_MDF
			// else
			// 	newId = s.XOId;

			//if (s.pXOId == 0 && s.XOId < 0)
			if (s.pXOId == 0)   // Parent
			{
				oldPrnt = s.XOId;
				newId = WriteRec(s);
				newPrnt = newId;
				s.XOId = newId;

			}
			else
			{
				s.pXOId = newPrnt;
				newId = WriteRec(s);
				s.XOId = newId;
			}
			//if (s.pXOId < 0 && oldPrnt == s.pXOId)


			// // Root and New
			// if (s.pXOId == 0 && s.XOId < 0)
			// 	//if (s.pXOId == 0 && s.XOId < 0)
			// {
			// 	oldId = s.XOId;
			// 	newId = d++;        // newId = XO_MDF
			// 	s.XOId = newId;
			// }

			// if(s.pXOId < 0 && oldId == s.pXOId)
			// {
			// 	s.pXOId = newId;
			// }
		}

		KaydetBeforeAfter(before: false);
		ChangeCount();
	}

	private void KaydetBeforeAfter(bool before)
	{
		// Root Idx leri LIFO koy stack
		int idx = 0;
		Stack<int> myStack = new();

		foreach (var s in sl)
		{
			if (s.pXOId == 0)
				myStack.Push(idx);

			idx++;
		}

		foreach (var f in myStack)
		{
			if (before)
				KaydetBefore(f);
			else
				KaydetAfter(f);
		}
	}

	private void KaydetBefore(int ridx)
	{
		// Sadece root idx gelir
		// Child first/last index
		int mId = sl[ridx].mXOId;
		int fi = ridx;
		var li = sl.FindLastIndex((z) => z.mXOId == mId);
		if (sl[ridx].isDeleted)    // Delete Child then Root
		{
			// Slaveleri sil, eski/yeni farketmez (DB zaten silecek)
			for (int y = li; y > fi; y--)
			{
				sl.RemoveAt(y);
			}
			if (sl[ridx].XOId <= 0)  // Root Yeni ise sil, eskiyse kalsın DB silecek
			{
				sl.RemoveAt(ridx);
			}
		}
		else // Child, İçinde sil varsa, Root dışında
		{
			for (int y = li; y > fi; y--)
			{
				// Yeniyse sil, değilse bırak DB silecek
				if (sl[y].isDeleted && sl[y].XOId <= 0)
					sl.RemoveAt(y);
			}
		}
	}
	private void KaydetAfter(int ridx)
	{
		// Sadece root idx gelir
		// DB ile eşle, tekrar okumamak için

		// Childs
		int mId = sl[ridx].mXOId;
		int fi = ridx;
		var li = sl.FindLastIndex((z) => z.mXOId == mId);

		if (sl[ridx].isDeleted)    // Root
		{
			// Hepsini sil
			for (int y = li; y >= fi; y--)
			{
				sl.RemoveAt(y);
			}
		}
		else // İçinde sil varsa, Root dışında
		{
			for (int y = li; y > fi; y--)
			{
				if (sl[y].isDeleted)
					sl.RemoveAt(y);
			}
		}
	}

	private void SilToggle(int idx)
	{   // XOId < 0 ise yeni eklenmiş
		// pXOId = 0 ise Root
		sl[idx].isDeleted = !sl[idx].isDeleted;
		ChangeCount();


		// if (sl[idx].pXOId == 0) // Ana
		// {
		// 	// İçindeki sonradan eklenmişleri remove
		// 	// Diğerlerine Del flagı koy
		// 	// Veya sadece D koy belki vazgeçer,
		// 	// birdaha Del'e basarsa eski haline döndür
		// 	// Del toggle sadece Sel kayıtlarında olmalı
		// 	int mId = sl[idx].mXOId;
		// 	int fi = idx;
		// 	var li = sl.FindLastIndex((z) => z.mXOId == mId);
		// 	for (int y = li; y >= fi; y--)
		// 	{
		// 		if (sl[y].XOId < 0)
		// 			sl.RemoveAt(y);
		// 		else
		// 			sl[y].Typ = "D";
		// 	}
		// }
		// else
		// {
		// 	if (sl[idx].XOId < 0)
		// 		sl.RemoveAt(idx);
		// 	else
		// 		sl[idx].Typ = "D";

		// }

	}

	private void AddSlave(int idx)
	{
		XO x = new();
		x.Typ = "I";
		x.mXOId = sl[idx].mXOId;
		x.XOId = c;
		x.pXOId = sl[idx].XOId;

		sl.Insert(idx + 1, x);
		c--;

	}

	private void AddMaster()
	{
		sl.Add(new XO { Typ = "I", mXOId = c, XOId = c, pXOId = 0 });
		c--;
	}

	private int WriteRec(XO r)
	{
		// Buraya temiz kayıtlar gelir
		// XOId ye göre Ins/Upd DB de (Sadece D önemli)
		r.Typ = r.isDeleted ? "D" : "U";

		int newId = 0;
		try
		{
			using var conn = db.GetConnection();
			newId = conn.ExecuteScalar<int>("XO_MDF",
					new
					{
						p1 = my.Id,
						p2 = XXId,
						p3 = r.Typ,
						p4 = r.mXOId,
						p5 = r.XOId,
						p6 = r.pXOId,
						p7 = r.dGun,
						p8 = r.RSD,
						p9 = r.RPH,
						pa = r.TskId,
						pb = r.SrvId,
						pc = r.ActId,
						pd = r.Inf,
						pe = r.Rf1,
						pf = r.Rf2,
					},
					commandType: CommandType.StoredProcedure);

		}
		catch (Exception ex)
		{
			var hata = ex.Message.Split("\r\n")[1];
			Modal.Show<ModalWarning>(hata);
		}
		return newId;

	}
	private async Task Read()
	{
		try
		{
			using var conn = db.GetConnection();
			sl = (await conn.QueryAsync<XO>("XO_QRY",
				new { a = my.Id, b = XXId }, // SP parametreleri DB deki sırasıyla gönderilmeli
				commandType: CommandType.StoredProcedure)
			).ToList();

			//Notifier.Notify += OnNotify;
		}
		catch (Exception ex)
		{
			var hata = ex.Message.Split("\r\n")[1];
			Modal.Show<ModalConfirm>(hata);
		}
	}

	protected override async Task OnInitializedAsync()
	{
		await Read();

		using var conn = db.GetConnection();
		ssd = conn.Query<SS>("SS_LU", new { UsrId = my.Id, FFId = my.FrmId }, commandType: CommandType.StoredProcedure).ToDictionary(k => k.Ad, e => e.Id);
		ttd = conn.Query<TT>("TT_LU", new { FFId = my.FrmId }, commandType: CommandType.StoredProcedure).ToDictionary(k => k.Ad, e => e.Id);
	}


	public sealed class SS
	{
		public int Id;
		public string Ad;
	}
	public sealed class TT
	{
		public int Id;
		public string Ad;
		public string? Inf;
	}
	public sealed class UU
	{
		public int Id;
		public string Ad;
	}
}
